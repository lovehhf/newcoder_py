# -*- coding:utf-8 -*-

__author__ = 'huanghf'

"""

PayPal上海团队一直致力于风险控制，风控需要收集各种信息，有时需要通过地理位置找出用户与用户之间存在的关联关系，
这一信息可能会用于找出用户潜在存在的风险问题。我们记两个用户的关联关系可以表示为：

(1). user1，user2与他们最常发生交易的地理位置分别为(x1, y1)，(x2, y2)，当这两个用户的欧氏距离不超过d时，我们就认为两个用户关联。
(2). **用户关联性具有传递性**，若用户1与用户2关联，用户2与用户3关联，那么用户1，2，3均关联。

给定N个用户及其地理位置坐标，将用户按照关联性进行划分，要求返回一个集合，集合中每个元素是属于同一个范围的用户群。

输入描述:
d:欧式距离
N:用户数

之后的N行表示第0个用户到第N-1个用户的地理位置坐标

输出描述:
一个数组集合，所有关联的用户在一个数组中。
输出数组需要按照从小到大的顺序排序，每个集合内的数组也需要按照从小到大的顺序排序。

输入例子1:
2.0
5
3.0 5.0
6.0 13.0
2.0 6.0
7.0 12.0
0.0 2.0

输出例子1:
[[0, 2], [1, 3], [4]]

欧氏距离（Euclid Distance）也称欧几里得度量、欧几里得距离,
是一个通常采用的距离定义,它是在m维空间中两个点之间的真实距离.在二维空间中的欧氏距离就是两点之间的直线段距离.
"""


def solve(d, n, grid):
    r = [[] for _ in range(n)]
    s = {x for x in range(n)}
    for i in range(n - 1):
        x1, y1 = grid[i][0], grid[i][1]
        for j in range(i + 1, n):
            x2, y2 = grid[j][0], grid[j][1]
            td = ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5  # 欧氏距离
            if td - d <= 1e-6:
                r[i].append(j)
                r[j].append(i)
                s -= {i, j}
    # print(s)
    # print(r)
    # for i in range(n):
    #     print(i, r[i])
    # print(grid[5],grid[0])
    res = []
    visited = set()
    for i in range(n):
        if not r[i] or (i in visited):
            continue
        queue = [i] + r[i]
        t = set()
        # print(queue,visited)
        visited.add(i)
        while queue:
            cur = queue.pop(0)
            t.add(cur)
            if r[cur] and not cur in visited:
                visited.add(cur)
                queue.extend(r[cur])
        res.append(sorted(t))

    res += [[x] for x in s]
    res = sorted(res)
    print(res)


def test():
    d = 12.6
    n = 100
    grid = [[11.12, 99.45], [87.04, 54.52], [8.49, 56.22], [44.36, 63.42], [51.64, 16.18], [78.87, 44.55],
            [68.98, 8.36], [38.5, 60.72], [8.9, 18.52], [66.65, 69.37], [16.94, 89.92], [2.91, 95.37], [88.73, 67.56],
            [48.36, 10.49], [77.66, 81.33], [19.84, 23.79], [93.73, 53.5], [70.4, 84.37], [2.96, 45.82], [71.81, 86.02],
            [25.85, 32.62], [38.68, 41.81], [37.4, 97.38], [23.97, 66.08], [91.64, 2.62], [30.52, 60.87],
            [28.77, 75.35], [64.51, 54.66], [74.76, 83.85], [3.17, 82.11], [9.85, 55.38], [61.39, 25.37],
            [64.98, 98.91], [19.56, 59.94], [3.41, 52.19], [18.59, 60.89], [58.39, 68.43], [37.04, 28.99],
            [27.38, 93.92], [40.0, 90.5], [68.04, 65.41], [29.76, 9.24], [2.14, 73.34], [34.22, 25.04], [9.62, 95.71],
            [40.49, 98.77], [86.92, 5.87], [18.53, 0.91], [51.52, 97.44], [82.42, 28.02], [97.19, 49.6], [5.07, 69.3],
            [43.87, 76.62], [36.86, 74.31], [80.08, 67.32], [77.6, 91.9], [65.82, 21.78], [17.34, 60.42],
            [49.76, 35.59], [91.91, 29.64], [55.63, 65.11], [95.93, 86.18], [9.62, 31.09], [58.24, 35.57],
            [13.12, 82.71], [12.43, 66.84], [13.45, 49.13], [88.7, 88.32], [88.66, 51.46], [12.21, 76.92],
            [42.25, 34.59], [18.11, 27.49], [98.4, 5.19], [83.28, 23.66], [98.97, 30.16], [31.31, 77.16],
            [30.12, 57.63], [88.39, 98.54], [47.77, 72.19], [55.23, 69.07], [29.1, 84.83], [12.87, 81.05],
            [50.15, 89.02], [98.83, 1.52], [78.53, 84.48], [73.81, 93.22], [74.51, 82.02], [49.29, 95.63],
            [13.84, 54.87], [61.39, 29.04], [81.36, 94.3], [57.4, 34.96], [35.52, 60.97], [8.04, 7.26], [11.1, 97.25],
            [70.59, 0.15], [9.76, 80.16], [6.05, 21.77], [26.16, 50.0], [96.66, 34.61]]
    solve(d, n, grid)


def main():
    grid = []
    d = float(input())
    n = int(input())
    for _ in range(n):
        grid.append(list(map(float, input().split())))
    solve(d, n, grid)


def test2():
    x1, y1 = [78.87, 44.55]
    for x2, y2 in [[87.04, 54.52], [93.73, 53.5], [97.19, 49.6], [88.66, 51.46]]:
        print(((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5)


main()
