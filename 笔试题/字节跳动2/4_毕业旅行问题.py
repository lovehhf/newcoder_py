# -*- coding:utf-8 -*-

__author__ = 'huanghf'

"""
小明目前在做一份毕业旅行的规划。

打算从北京出发，分别去若干个城市，然后再回到北京，每个城市之间均乘坐高铁，且每个城市只去一次。

由于经费有限，希望能够通过合理的路线安排尽可能的省些路上的花销。

给定一组城市和每对城市之间的火车票的价钱，找到每个城市只访问一次并返回起点的最小车费花销。

输入格式
城市个数n。

城市间的车票价钱n行n列的矩阵 m[n][n]

输出格式
输出一个整数，表示最小车费花销。

数据范围
1<n≤20,包括北京
车票价格均不超过1000元。

输入样例：
4
0 2 6 5
2 0 4 4
6 4 0 2
5 4 2 0
输出样例：
13
说明
共4个城市，城市1和城市1的车费为0，城市1和城市2之间的车费为2，城市1和城市3之间的车费为6，城市1和城市4之间的车费为5，以此类推。

假设任意两个城市之间均有单程票可买，且价格均在1000元以内，无需考虑极端情况。

20
0 50 10 80 44 50 39 63 93 24 48 7 72 19 24 28 100 16 100 23
50 0 36 79 86 34 49 25 68 29 4 8 6 77 99 68 21 73 37 22
10 36 0 45 29 21 38 6 65 79 35 49 98 47 23 91 19 63 80 56
80 79 45 0 32 8 40 6 50 12 98 13 65 23 52 42 90 62 95 88
44 86 29 32 0 39 78 27 35 86 19 60 28 64 35 10 11 79 13 52
50 34 21 8 39 0 63 6 38 9 76 62 93 66 62 46 82 49 74 65
39 49 38 40 78 63 0 9 45 54 14 5 12 51 83 47 11 39 80 13
63 25 6 6 27 6 9 0 8 28 82 12 19 5 70 90 73 6 75 79
93 68 65 50 35 38 45 8 0 22 9 13 56 16 95 88 57 21 35 13
24 29 79 12 86 9 54 28 22 0 4 93 58 82 18 20 84 96 89 3
48 4 35 98 19 76 14 82 9 4 0 9 89 56 41 68 31 63 83 8
7 8 49 13 60 62 5 12 13 93 9 0 72 80 79 55 90 78 4 88
72 6 98 65 28 93 12 19 56 58 89 72 0 50 18 68 27 60 11 46
19 77 47 23 64 66 51 5 16 82 56 80 50 0 20 38 73 10 66 42
24 99 23 52 35 62 83 70 95 18 41 79 18 20 0 91 10 17 24 37
28 68 91 42 10 46 47 90 88 20 68 55 68 38 91 0 90 67 38 78
100 21 19 90 11 82 11 73 57 84 31 90 27 73 10 90 0 51 69 45
16 73 63 62 79 49 39 6 21 96 63 78 60 10 17 67 51 0 17 13
100 37 80 95 13 74 80 75 35 89 83 4 11 66 24 38 69 17 0 72
23 22 56 88 52 65 13 79 13 3 8 88 46 42 37 78 45 13 72 0

196
"""

from  itertools import permutations

n = int(input())
N = []

for i in range(n):
    line = list(map(int,input().split(' ')))
    N.append(line)

# n = 4
# N = [[0, 2, 6, 5],
#      [2, 0, 4, 4],
#      [6, 4, 0, 2],
#      [5, 4, 2, 0]]

# dp[i][j]表示从i到j最低花销
# dp = [[0]*n]*n
t = []

for i in permutations(list(range(1,n))):
    t.append(list(i))

t = [[0]+x+[0] for x in t]

def fun(x):
    tmp = []
    for i in range(1,n+1):
        tmp.append([x[i-1],x[i]])
    return tmp

# 所有路线
t = list(map(fun,t))

t1 = [sum(list(map(lambda a:N[a[0]][a[1]],x))) for x in t]

# 最少花费
print(min(t1))